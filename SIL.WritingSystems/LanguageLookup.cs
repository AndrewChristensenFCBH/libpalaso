// Copyright (c) 2016-2017 SIL International
// This software is licensed under the MIT License (http://opensource.org/licenses/MIT)

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using SIL.Code;
using SIL.Text;

namespace SIL.WritingSystems
{
	/// <summary>
	/// Lets you find a language using data from the Ethnologue, IANA subtag repository and the SLDR.
	/// It obtains the data from LanguageDataIndex.txt which has been generated by the LanguageData program
	///
	/// We want to keep all fields in LanguageInfo corresponding to columns in LanguageDataIndex.txt and fields
	/// in LanguageDataIndex.json which are generated by code in the LanguageDataIndex constructor from information
	/// retrieved from ethnologue.com and other sources by code in GetAndCheckSources when the LanguageData program
	/// is run. (One reason is so it will also be available to web apps using the json file.)
	///
	/// So, any new information that the code here needs to initialize in LanguageInfo objects should not be
	/// computed here, but computed or retrieved from the sources in LanguageDataIndex(), added to
	/// LanguageDataIndex.txt and.json, and then simply read into the appropriate fields here.
	/// </summary>
	public class LanguageLookup
	{
		private readonly Dictionary<string, LanguageInfo> _codeToLanguageIndex = new Dictionary<string, LanguageInfo>();
		private readonly Dictionary<string, List<LanguageInfo>> _nameToLanguageIndex = new Dictionary<string, List<LanguageInfo>>();
		private readonly Dictionary<string, List<LanguageInfo>> _countryToLanguageIndex = new Dictionary<string, List<LanguageInfo>>();

		/// <summary>
		/// Initializes a new instance of the <see cref="LanguageLookup"/> class.
		/// It gets its data from the LanguageDataIndex resource
		/// </summary>
		public LanguageLookup()
		{
			// TODO: modify to load from json instead of LanguageDataIndex

			var allTagsContent = LanguageRegistryResources.alltags_json;

			List<AllTagEntry> rootObject = JsonConvert.DeserializeObject<List<AllTagEntry>>(allTagsContent);

			foreach (AllTagEntry entry in rootObject)
			{
				if (!entry.deprecated)
				{
					AddLanguage(entry.tag, entry.iso639_3, entry.full, entry.name, entry.region, entry.names, entry.tags);
				}
			}
			AddLanguage("qaa", "qaa", "qaa", "Unlisted Language");


			//// Load from file into the data structures instead of creating it from scratch
			//var entries = LanguageRegistryResources.LanguageDataIndex.Replace("\r\n", "\n").Split(new[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);

			//foreach (string entry in entries)
			//{
			//	// Fields in LanguageDataIndex
			//	// Code ThreeLetterCode DesiredName Names Countries PrimaryCountry
			//	string[] items = entry.Split('\t');
			//	if (items.Length != 7) // This needs to be changed if the number of fields changes
			//		continue;
			//	string code = items[0];
			//	string threelettercode = items[1];
			//	string desiredname = items[2];
			//	bool macrolanguage = String.Equals("M", items[3]);
			//	string[] names = items[4].Split(';');
			//	string[] countries = items[5].Split(';');
			//	string primarycountry = items[6];
			//	LanguageInfo language = new LanguageInfo { LanguageTag = code, ThreeLetterTag = threelettercode, DesiredName = desiredname,
			//		IsMacroLanguage = macrolanguage, PrimaryCountry = primarycountry };
			//	foreach (string country in countries)
			//	{
			//		language.Countries.Add(country);
			//	}
			//	foreach (string langname in names)
			//	{
			//		language.Names.Add(langname.Trim());
			//	}

			//	// Do not add anything to LanguageInfo manually here if it would be useful in LanguageDataIndex.txt/json

			//	// add language to _codeToLanguageIndex and _nameToLanguageIndex
			//	// if 2 letter code then add both 2 and 3 letter codes to _codeToLanguageIndex

			//	_codeToLanguageIndex[code] = language;
			//	if (!String.Equals(code, threelettercode))
			//	{
			//		_codeToLanguageIndex[threelettercode] = language;
			//	}
			//	foreach (string langname in language.Names)
			//		GetOrCreateListFromName(langname).Add(language);
			//	// add to _countryToLanguageIndex
			//	foreach (var country in language.Countries)
			//	{
			//		if (!string.IsNullOrEmpty(country))
			//		{
			//			List<LanguageInfo> list;
			//			if (!_countryToLanguageIndex.TryGetValue(country, out list))
			//			{
			//				list = new List<LanguageInfo>();
			//				_countryToLanguageIndex[country] = list;
			//			}
			//			list.Add(language);
			//		}
			//	}
			//}
		}

		private bool AddLanguage(string code, string threelettercode, string full = null,
			string desiredname = null, string region = null, List<string> names = null, List<string> tags = null)
		{
			if (desiredname == null)
			{
				desiredname = code; // temp workaround for data missing names
			}
			//bool macrolanguage = String.Equals("M", items[3]); // TODO macrolanguages? are the ones we don't want in the data?
			//string[] countries = items[5].Split(';');
			string primarycountry;
			if (region == null)
			{
				primarycountry = "";
			}
			else if (StandardSubtags.IsValidIso3166RegionCode(region))
			{
				if (StandardSubtags.IsPrivateUseRegionCode(region))
				{
					if (region == "XK")
					{
						primarycountry = "Kosovo";
					}
					else
					{
						primarycountry = "Unknown private use";
					}
				}
				else
				{
					primarycountry = StandardSubtags.RegisteredRegions[region].Name; // convert to full region name
				}
			}
			else
			{
				primarycountry = "Invalid region";
			}
			LanguageInfo language = new LanguageInfo
			{
				LanguageTag = code,
				ThreeLetterTag = threelettercode,
				DesiredName = desiredname,
				//IsMacroLanguage = macrolanguage,
				PrimaryCountry = primarycountry
			};
			//foreach (string country in countries)
			//{
			//	language.Countries.Add(country);
			//}
			language.Countries.Add(primarycountry);
			//Why just this small set? Only out of convenience. Ideally we'd have a db of all languages as they write it in their literature.
			string localName = null;
			switch (desiredname)
			{
				case "French":
					localName = "français";
					break;
				case "Spanish":
					localName = "español";
					break;
				case "Chinese":
					localName = "中文";
					break;
				case "Hindi":
					localName = "हिन्दी";
					break;
				case "Bengali":
					localName = "বাংলা";
					break;
				case "Telugu":
					localName = "తెలుగు";
					break;
				case "Tamil":
					localName = "தமிழ்";
					break;
				case "Urdu":
					localName = "اُردُو";
					break;
				case "Arabic":
					localName = "العربية/عربي";
					break;
				case "Thai":
					localName = "ภาษาไทย";
					break;
				case "Indonesian":
					localName = "Bahasa Indonesia";
					break;
			}
			if (localName != null)
			{
				language.Names.Add(localName);
			}
			language.Names.Add(desiredname.Trim());
			if (names != null)
			{
				foreach (string langname in names)
				{
					language.Names.Add(langname.Trim());
				}
			}
			// add language to _codeToLanguageIndex and _nameToLanguageIndex
			// if 2 letter code then add both 2 and 3 letter codes to _codeToLanguageIndex

			_codeToLanguageIndex[code] = language;
			if (full != null)
			{
				_codeToLanguageIndex[full] = language; // add the full expanded tag
			}

			if (threelettercode != null && !String.Equals(code, threelettercode))
			{
				_codeToLanguageIndex[threelettercode] = language;
			}

			if (tags != null)
			{
				foreach (string langtag in tags)
				{
					_codeToLanguageIndex[langtag] = language;
				}
			}

			foreach (string langname in language.Names)
				GetOrCreateListFromName(langname).Add(language);
			// add to _countryToLanguageIndex
			foreach (var country in language.Countries)
			{
				if (!string.IsNullOrEmpty(country))
				{
					List<LanguageInfo> list;
					if (!_countryToLanguageIndex.TryGetValue(country, out list))
					{
						list = new List<LanguageInfo>();
						_countryToLanguageIndex[country] = list;
					}
					list.Add(language);
				}
			}

			return true;
		}


		/// <summary>
		///  For testing; used to detect if we need more special cases where LanguageDataIndex()
		///  populates LanguageInfo.PrimaryCountry.
		/// </summary>
		/// <returns></returns>
		internal List<LanguageInfo> LanguagesWithoutRegions()
		{
			var result = new List<LanguageInfo>();
			foreach (var lang in _codeToLanguageIndex.Values)
			{
				if (String.IsNullOrEmpty(lang.PrimaryCountry))
					result.Add(lang);
			}
			return result;
		}

		private List<LanguageInfo> GetOrCreateListFromName(string name)
		{
			List<LanguageInfo> languages;
			if (!_nameToLanguageIndex.TryGetValue(name, out languages))
			{
				languages = new List<LanguageInfo>();
				_nameToLanguageIndex.Add(name, languages);
			}
			return languages;
		}

		/// <summary>
		/// Just lookup the code in the index.
		/// </summary>
		/// <returns>null if not found</returns>
		public LanguageInfo GetLanguageFromCode(string isoCode)
		{
			Guard.AgainstNullOrEmptyString(isoCode, "Parameter to GetLanguageFromCode must not be null or empty.");
			LanguageInfo languageInfo = null;
			_codeToLanguageIndex.TryGetValue(isoCode, out languageInfo);
			return languageInfo;
		}

		/// <summary>
		/// Get an list of languages that match the given string in some way (code, name, country)
		/// </summary>
		public IEnumerable<LanguageInfo> SuggestLanguages(string searchString)
		{
			if (searchString != null)
				searchString = searchString.Trim();
			if (string.IsNullOrEmpty(searchString))
				yield break;

			if (searchString == "*")
			{
				// there will be duplicate LanguageInfo entries for 2 and 3 letter codes
				var all_languages = new HashSet<LanguageInfo>(_codeToLanguageIndex.Select(l => l.Value));
				foreach (LanguageInfo languageInfo in all_languages.OrderBy(l => l, new ResultComparer(searchString)))
					yield return languageInfo;
			}
			else
			{
				IEnumerable<LanguageInfo> matchOnCode = from x in _codeToLanguageIndex where x.Key.StartsWith(searchString, StringComparison.InvariantCultureIgnoreCase) select x.Value;
				List<LanguageInfo>[] matchOnName = (from x in _nameToLanguageIndex where x.Key.StartsWith(searchString, StringComparison.InvariantCultureIgnoreCase) select x.Value).ToArray();
				// Apostrophes can cause trouble in lookup.  Unicode TR-29 inexplicably says to use
				// u2019 (RIGHT SINGLE QUOTATION MARK) for the English apostrophe when it also defines
				// u02BC (MODIFIER LETTER APOSTROPHE) as a Letter character.  Users are quite likely to
				// type the ASCII apostrophe (u0027) which is defined as Punctuation.  The current
				// data appears to use u2019 in several language names, which means that users might
				// end up thinking the language isn't in our database.
				// See https://silbloom.myjetbrains.com/youtrack/issue/BL-6339.
				if (!matchOnName.Any() && searchString.Contains('\''))
				{
					searchString = searchString.Replace('\'','\u2019');
					matchOnName = (from x in _nameToLanguageIndex where x.Key.StartsWith(searchString, StringComparison.InvariantCultureIgnoreCase) select x.Value).ToArray();
				}
				List<LanguageInfo>[] matchOnCountry = (from x in _countryToLanguageIndex where x.Key.StartsWith(searchString, StringComparison.InvariantCultureIgnoreCase) select x.Value).ToArray();

				if (!matchOnName.Any())
				{
					// look  for approximate matches
					const int kMaxEditDistance = 3;
					var itemFormExtractor = new ApproximateMatcher.GetStringDelegate<KeyValuePair<string, List<LanguageInfo>>>(pair => pair.Key);
					IList<KeyValuePair<string, List<LanguageInfo>>> matches = ApproximateMatcher.FindClosestForms(_nameToLanguageIndex, itemFormExtractor,
						searchString,
						ApproximateMatcherOptions.None,
						kMaxEditDistance);
					matchOnName = (from m in matches select m.Value).ToArray();
				}

				var combined = new HashSet<LanguageInfo>(matchOnCode);
				foreach (List<LanguageInfo> l in matchOnName)
					combined.UnionWith(l);
				foreach (List<LanguageInfo> l in matchOnCountry)
					combined.UnionWith(l);
				foreach (LanguageInfo languageInfo in combined.OrderBy(l => l, new ResultComparer(searchString)))
					yield return languageInfo;
			}
		}

		private class ResultComparer : IComparer<LanguageInfo>
		{
			private readonly string _searchString;
			private readonly string _lowerSearch;

			public ResultComparer(string searchString)
			{
				_searchString = searchString;
				_lowerSearch = searchString.ToLowerInvariant();
			}

			public int Compare(LanguageInfo x, LanguageInfo y)
			{
				if (x.LanguageTag == y.LanguageTag)
					return 0;
				if (!x.Names[0].Equals(y.Names[0], StringComparison.InvariantCultureIgnoreCase))
				{
					// Favor ones where some language matches to solve BL-1141
					if (x.Names[0].Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
						return -1;
					if (y.Names[0].Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
						return 1;
					if (x.Names.Count > 1 && x.Names[1].Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
						return -1;
					if (y.Names.Count > 1 && y.Names[1].Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
						return 1;
				}

				if (x.LanguageTag.Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
					return -1;
				if (y.LanguageTag.Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
					return 1;

				// TODO This part does tag validation which is unhelpful. Any simpler way to get the language part?
				if (IetfLanguageTag.GetLanguagePart(x.LanguageTag, false).Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
					return -1;
				if (IetfLanguageTag.GetLanguagePart(y.LanguageTag, false).Equals(_searchString, StringComparison.InvariantCultureIgnoreCase))
					return 1;

				// Use the "editing distance" relative to the search string to sort by the primary name.
				// (But we don't really care once the editing distance gets very large.)
				// See https://silbloom.myjetbrains.com/youtrack/issue/BL-5847 for motivation.
				// Timing tests indicate that 1) calculating these distances doesn't slow down the sorting noticeably
				// and 2) caching these distances in a dictionary also doesn't speed up the sorting noticeably.
				var xDistance = ApproximateMatcher.EditDistance(_lowerSearch, x.Names[0].ToLowerInvariant(), 25, false);
				var yDistance = ApproximateMatcher.EditDistance(_lowerSearch, y.Names[0].ToLowerInvariant(), 25, false);
				var distanceDiff = xDistance - yDistance;
				if (distanceDiff != 0)
					return distanceDiff;

				// If the editing distances for the primary names are the same, sort by the primary name.
				int res = string.Compare(x.Names[0], y.Names[0], StringComparison.InvariantCultureIgnoreCase);
				if (res != 0)
					return res;

				return string.Compare(x.LanguageTag, y.LanguageTag, StringComparison.InvariantCultureIgnoreCase);
			}
		}
	}
}
